Сложность решения задач.

Программирование по сути -- это построение вычислительной модели некоторой системы на формальном языке.

В физике часто строят модель, проверяют на ней некоторые свойства, и это прекрасно работает.
В программировании так не работает, просто потому, что само по себе ПО не может быть проще, чем моделируемая им реальность.
Например, нельзя суперпросто решить сеточным методом уравнение проще, чем сам алгоритм.

Существенная сложность -- сложность, присущая решаемой проблеме. 
Ею можно управлять, но от нее нельзя избавиться.

Случайная сложность -- сложность, привнесенная способом решения проблемы.

Хорошие новости в том, что сложные системы обладают рядом полезных свойств:

Несмотря на то, что системы и программы сложны, большинство систем иерархичны.

-- Иерархичность -- свойство системы состоять из иерархии подсистем или компонентов -- декомпозиция (и так несколько раз)

-- Наличие относительно небольшого количества _видов_ компонентов, экземпляры которых сложно связаны друг с другом -- типизируемость
	-- Выделение общих свойств компонентов, абстрагирование

-- Сложная система, как правило, является результатом эволюции простой системы
-- Сложность вполне может превосходить человеческие интеллектуальные возможности.

Подходы к декомпозиции -- разделяй и властвуй
-- Восходящее проектирование -- сначала создаем кирпичики, потом собираем из них все более сложные системы -- некоторые библиотеки, нейросетевые пайплайны
+ легко тестируемое
- возможно, что-то окажется лишним
-- Нисходящее проектирование -- накинуть решение задачи в целом, используя заглушки, а потом конкретизируем
Делим на крупные подзадачи, но они работают совместно
	-- Постепенная реализация модулей
	-- Строгое задание интерфейсов
	-- Активное использование "заглушек"
	-- Молули: -- могут быть подпрограммы или отдельные классы. Это единица декомпозиции.
		-- Четкая декомпозиция -- каждый модуль знает, что он делает.
		-- Минимизация внешнего интерфейса -- "меньше знаешь -- крепче спишь". Проще пользоваться.
		-- Один модуль -- одна функциональность
		-- Отстутствие побочных эффектов (спорно -- в ООП у каждого объекта есть свое состояние)
		-- Независимость от реализации других модулей -- модули не должны знать и зависеть от внутренней реализации
		-- Принцип сокрытия данных

+ направленность деятельности архитектора и разработки
-- следовательно, движемся к строго намеченной цели, выкидывая при этом некоторые ненужные действия.

Модульность
Можно бесконечно дробить задачу
-- Разделение системы на компоненты
-- Позволяет создавать сколь угодно сложные системы
-- Независимость разработки
-- Необходим баланс между количеством и размером модулей

Размер модуля ~ стоимость его разработки
Малые модули ~ стоимость их интеграции

Принято: 1 файл не должен быть размером больше xx строчек, не должно быть уу файлов в одной компоненте.

Сопряжение и связность -- метрики.

-- Coupling -- мера того, насколько взаимозависимы разные модули в программе (по вызовам, как правило)
-- Соhesion -- стапень, в которой задачи, выполняемые одним модулем, связаны друг с другом (в плане смысла)
Цель--слабое сопряжение и сильная связность


---------
Объекты

С точки зрения по архитектуре они по традиции более интересны.

Суть объекта в том, что у него есть внешнее поведение и внутреннее состояние -- единица декомпозиции.
Объекты имеют:
-- Состояние 
	-- инвариант -- набор логических условий на состояние объекта на все время жизни.
	(например, длина списка size отражает количество элеметов в нем). Они, как правило, не выписываются явно.
	(но иногда компилятор может подставлять проверки сам, либо это делается специальными библиотеками).
-- Поведение
-- Идентичность -- способ сказать про два объекта, один это объект или два разных

Взаимодействуют через посылку и прием сообщений
-- Объект вправе сам решить, как обработать вызов метода (полиморфизм) -- управление не передается прямо по заранее заданному адресу -- позднее связывание
-- Могут существовать в разных потоках

Как правило, являются экземплярами классов. (JS -- есть ключевое слово класс, но это скорее фабричный метод).

Самое важное -- АБСТРАКЦИЯ -- это не свойство ООП, а свойство программирования и человеческого мышления
Позволяет выделить сузественные характеристики объекта, отличающие его от оствльых объектов, с точки зрения наблюдателя
(Гради, Буч, картинка из книги)
Кот -- 1 объект является 2 абстракциями одновременно.

Инкапсуляция -- разделяет интерфейс (контракты) абстракции и ее реализацию
Она защищает инварианты абстракции

Инкапсуляция -- это свойство кода, решающего 1 задачу, находиться физически где-то рядом друг с другом
Сокрытие деталей реализации -- свойство кода не раскрывать для внешнего мира свое внутреннее устройство

Для структурного программирования это разные понятия
Для ООП реализуется одним и тем же механизмом -- класс. Прячем private часть. А находится это, как правило, в 1 файле.

Наследование
	-- Отношение "Является" классификации над типами (в private -- наследовании С++ это правило нарушается)
	-- Способ абстрагирования и классификации
	-- Средство обеспечение полиморфизма
Композиция
	-- Отношение "Имеет" отношения включения
	-- Способ создания динамических связей
	-- Средство обеспечения делегирования
Более-менее взаимозаменяемые
	-- Объект-потомок на самом деле включает в себя объект-предок
	-- Композиция обычно предпочтительнее

Наследование фиксируется при компиляции, а композиция динамична по сути. Композиция модет вести себя так, будто объект в рантайме меняет тип.
Наследование нужно, если в предметной области есть классификация, и когда работаем со всякими иерархичными структурами -- компиляторы, грамматики, и др.
И где реализуется полиморфный интерфейс.

--
Откуда берутся объекты? Из реального мира:

Объектная модель предметной области -- ООП близко к реального мира, и сущности перекладываются на код:
1) Выделить сущности и свойства -- объекты и их атрибуты (объект и атрибут не сильно различается. Например, адрес).
2) Определение действий, которые будут выполнены над каждым объектом (назрачение ответственности).
3) Определение связей между объектами.
4) Определение интерфейса каждого объекта.

Есть еще источники объектов, возникающих из сложности задачи:
-- сложные алгоритмы могут быть инкапсулированы
-- сложные структуры данных -- тоже
-- и даже сложные подсистемы
-- надо внимательно следить за интерфейсами

Изоляция возможных изменений -- тоже источник объектов

-- Потенциальные изменения могут быть инкапсулированы
-- Источники:
 	-- Бизнес-правила
	-- Зависимости от оборудования о ОС, системного софта
	-- ввод-вывод
	-- Нестандартные возможности языка (зависимость от компилятора)
	-- Сложные аспекты проектирования и конструирования
	-- Третьесторонние компоненты
        -- и др

Изоляция служебной информации -- тоже источник объектов!

Служебная ф-ть может быть инкапсулирована 
-- Репозитории
-- Фабрики
-- Диспетчеры, медиаторы
	-- медиатор -- объект, обеспечивающий взаимодействие группы объектов -- шина, в которую кидают события, и объекты на них подписаны
-- Статические классы (сервисы)
-- и др

-- 
Принципы проектирования
--
SOLID -- красивый ООП дизайн

Single responsibility principle
--Каждый объект должен иметь одну обязанность
-- Эта обязанность должна быть полностью инкапсулирована в объект
Open/closed principle
-- Программные сущности (классы, модули, функции, и др) должны быть открыты для расширения, 
но закрыты для изменения
	-- переиспользование через наследование --> полиморфизм
	-- неизменные интерфейсы
То есть мы определяем однозначные точки для расширения, и их меняем.
В интерфейсной части систем используется меньше конкретных классов -- только виртуальные (интерфейсы) и сырые данные 
Account --> AccountType -- добавляем наследника и его уже меняем.
Liskov substitution principle
-- Это скорее определение наследования -- функции, которые используют базовый тип, должны использовать подтипы базового типа, не зная об этом
-- Если это потомок, и предок где-то используется, то и потомок должен использоваться там же.
   И инварианты предка должны выполняться в потомке.
Interface segregation principle
-- Клиенты не должны зависеть от методов, которые они не используют
	-- слишком толстые интерфейсы необходимо разделять на более мелкие и специфические
Пример: интерфейс gsm-модема разделен на сетевую и стриминговую часть
Удобство: не перекомпилировать клиента 2, если что-то изменилось для клиента 1
Dependency inversion
-- Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
-- Абстракции не должны зависеть от делалей. Детали должны зависеть от абстракции.

Не использовать прямые зависимости одних классов от других.
Выделять интерфейс, делать так, чтобы SWITCH-->SWITCHABLE-->LIGHT
Это хорошо, что SWITCHABLE может исп. с любым объектом, который можно вкл и выкл, 
теперь мы можем менять и выключатель.

SWITCH может принимать SWITCHABLE в конструктор.
Этот принцип может усложнить отладку.


Закон Деметры.
Объект А не должен иметь возможность получить непосредственный доступ к объекту С, если у А есть доступ к B,
и у B есть доступ к C.
-- Объект не должен лазить в поля и методы чужого объекта, если не имеет к нему непосредственного отношения.
-- Если объект, от которого зависят, меняется, придется менять все зависящие объекты.
book.pages.last.text -- no
book.pages().last().text() -- maybe
book.lastPageText() -- ideally
