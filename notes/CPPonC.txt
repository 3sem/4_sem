В прошлом семестре мы смотрели, как подходят к симуляции наследования и полиморфизма в С.
Важно понимать, что по сути все эти принципы ООП живут, по большей части, в голове разработчика.

А теперь давайте представим, что у нас есть С, и мы хотим на его основе разработать С++.

Ключевой сущностью в С является структура. В С++ класс.

Если класс содержит метод (не виртуальный, не статический), то это почти то же самое, что и обычная функция в С (за исключением манглинга имени, конечно).

void f(int a, int b);

B::f(5,6); -- это всё равно что this -> f(5,6); Поэтому второе отличие -- это скрытый параметр this как указатель на объект. 
Конечно же, для множества объектов одного типа это одна и та же функция.
В некоторых ЯП, например, в Питоне, этот параметр даже явно прописывается в аргументах метода (как "self").

То, какая именно функция вызовется при вызове метода, определяется типом указателя this.

С этой же точки зрения, обращение к полю a внутри метода класса выглядит как this->a .

А вот дальше начинаются фундаментальные различия.

Как в C инициализировалась cтруктура? Только через initializer.

В С++ же для создания объекта решили вызывать функцию, вернее метод, называемый конструктором.

Но что делать, если конструктор не смог создать объект? Вопрос открытый. Можно, конечно, кидать исключение, но мы до них ещё не дошли...
Это значит, нужны статические методы класса. У них первым аргументом нету this. Их можно вызывать вне зависимости от создания объекта.

------

Вернемся к позднему связыванию и множественному наследованию.


------

Касты.

static_cast -- простейший каст, применяется для каста примитивных типов, либо вверх по иерархии, если не было виртуальных методов.

dynamic -- с динамической проверкой типа и _ПОДСТАНОВКОЙ НУЖНОЙ VFT_. Позволяет кастовать вверх и вниз по иерархии. 

В случае неуспеха возвращает nullptr либо std::bad_cast, если был вызван от ссылки.
Работает только со ссылками и указателями.

safe_cast -- почти то же , что dynamic, но кидает исключение в случае неуспеха.

reinterpret_cast -- для связывания неродственных классов в некоторых случаях (использовать в случаях, не нарушающих type strict aliasing)
